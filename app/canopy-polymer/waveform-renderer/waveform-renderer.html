<!--
  TODO
  - comments
  - zoomGain, zoomTime needs some refinements
  - clean up noise/residue on the off canvas
  - public width/height property, and onResize()
  - notify: event system
  - setting: sample/second
-->
<link rel="import" href="../../bower_components/polymer/polymer.html">

<script src="timeruler.js"></script>
<script src="ampruler.js"></script>
<script src="waveform.js"></script>
<script src="events.js"></script>

<polymer-element name="waveform-renderer" attibutes="width height">
  <template>
    <style>
      :host {
        width: 100%;
      }
    </style>
    <canvas id="eCanvas"></canvas>
  </template>

  <script>
    Polymer({

      ctx: null,
      cvsOff: null,
      ctxOff: null,

      width: 800,
      height: 500,

      start: 0,
      end: 0,
      absPeak: 1,

      timeRuler: null,
      ampRulers: null,
      waveformDrawers: null,

      renderedBuffer: null,

      pixelPerSample: 1,

      controller: null,

      _findAbsPeak: function () {
        if (!this.renderedBuffer)
          return 0;

        var numChannels = this.renderedBuffer.numberOfChannels;
        var absPeak = 0.0;
        for (var i = 0; i < numChannels; i++) {
          var data = this.renderedBuffer.getChannelData(i);
          for (var j = 0; j < data.length; j++) {
            var absValue = Math.abs(data[j]);
            if (absPeak < absValue)
              absPeak = absValue;
          }
        }

        return absPeak;
      },

      _zoom: function (deltaY, zoomCenter) {
        var factor = this.timeRuler.pixelsToSeconds(deltaY);
        var anchor = this.start + this.timeRuler.pixelsToSeconds(zoomCenter);

        // Estimate start/end points.
        var start = this.start - factor * anchor;
        var end = this.end + factor * (this.renderedBuffer.duration - anchor);
        start = Math.max(start, 0);
        end = Math.min(end, this.renderedBuffer.duration);

        // Zoom above the maximum zoom range: 0.001 seconds.
        if (end - start > 0.001) {
          this.start = start;
          this.end = end;
          this.render(this.start, this.end, this.absPeak);
          this.onChange();
        }
      },

      _zoomGain: function (deltaY) {
        var factor = deltaY * 0.01;
        this.absPeak += factor;
        this.absPeak = Math.max(0.01, this.absPeak);
        this.render(this.start, this.end, this.absPeak);
      },

      _pan: function (deltaX) {
        // Calculate deltaX in seconds and new start/end.
        var deltaSec = this.timeRuler.pixelsToSeconds(deltaX);
        var start = this.start + deltaSec;
        var end = this.end + deltaSec;

        // Pan only with the valid start/end position.
        if (0 <= start && end < this.renderedBuffer.duration) {
          this.start = start;
          this.end = end;
          this.render(this.start, this.end, this.absPeak);
          this.onChange();
        }
      },

      onChange: function () {
        if (!this.controller)
          return;
        
        var eventType = 'viewport-change';
        var data = {
          start: this.start,
          end: this.end
        };
        this.controller.notify('waveform', eventType, data);
      },

      _registerMouseHandler: function () {

        // UI mode = {ZOOMTIME, ZOOMGAIN, PAN, SELECT}
        var status;

        // origin, previous, delta.
        var ox;
        var px, py, dx, dy;

        var mouseHandler = new MouseResponder('Waveform', this.$.eCanvas,
          function (sender, action, data) {
            switch (action) {

              case 'clicked':
                if (data.x < 42)
                  status = 'ZOOMGAIN';
                ox = data.x;
                px = data.x;
                py = data.y;
                dx = dy = 0;
                break;

              case 'dragged':
                dx = px - data.x;
                dy = py - data.y;
                if (status !== 'ZOOMGAIN')
                  status = (dx * dx < dy * dy) ? 'ZOOMTIME' : 'PAN';

                switch (status) {
                  case 'ZOOMGAIN':
                    this._zoomGain(dy);
                    break;
                  case 'ZOOMTIME':
                    this._zoom(dy, data.x);
                    break;
                  case 'PAN':
                    this._pan(dx);
                    break;
                }

                px = data.x;
                py = data.y;
                break;
              
              case 'released':
                status = 'IDLE';
                break;

            }
          }.bind(this)
        );
      },

      setBuffer: function (buffer) {
        if (!buffer)
          return;

        this.renderedBuffer = buffer;

        var numChannels = this.renderedBuffer.numberOfChannels;

        var ampRulerWidth = 42;
        var timeRulerHeight = 32;
        var timeRulerWidth = this.width - ampRulerWidth;
        var channelHeight = (this.height - timeRulerHeight) / numChannels;

        this.timeRuler = WaveformRenderer.createTimeRuler(this.ctxOff,
          ampRulerWidth, 0, timeRulerWidth);

        this.ampRulers = [];
        this.waveformDrawers = [];
        for (var i = 0; i < numChannels; i++) {
          var yOffset = timeRulerHeight + i * channelHeight;
          var channelData = this.renderedBuffer.getChannelData(i);

          this.ampRulers[i] = WaveformRenderer.createAmpRuler(this.ctxOff,
            0, yOffset, ampRulerWidth, channelHeight);
          this.waveformDrawers[i] = WaveformRenderer.createWaveformDrawer(this.ctxOff,
            ampRulerWidth, yOffset, timeRulerWidth, channelHeight);

          this.waveformDrawers[i].setSampleData(channelData, this.renderedBuffer.sampleRate);
        }

        // By default: optimum view.
        this.start = 0;
        this.end = this.renderedBuffer.duration;
        this.absPeak = this._findAbsPeak();
        this.render(this.start, this.end, this.absPeak);
      },

      resize: function () {
        this.width = this.parentNode.offsetWidth;
        if (this.parentNode.offsetHeight > 500)
          this.height = this.parentNode.offsetHeight;

        // Sizing.
        this.$.eCanvas.width = this.cvsOff.width = this.width;
        this.$.eCanvas.height = this.cvsOff.height = this.height;

        // FIXME!
        this.setBuffer(this.renderedBuffer);
      },

      render: function (start, end, absPeak) {
        if (!this.renderedBuffer)
          return;

        this.ctxOff.clearRect(0, 0, this.width, this.height);

        var numChannels = this.renderedBuffer.numberOfChannels;

        for (var i = 0; i < numChannels; i++) {
          this.waveformDrawers[i].draw(start, end, absPeak);
          this.ampRulers[i].draw(absPeak);
        }
        this.timeRuler.draw(start, end);

        this.ctx.drawImage(this.cvsOff, 0, 0, this.width, this.height);
      },

      setController: function (controller) {
        this.controller = controller;
      },

      setViewPort: function (start, end) {
        this.start = start;
        this.end = end;
        this.render(this.start, this.end, this.absPeak);
      },

      ready: function () {
        // Create resources: canvas and context.
        this.ctx = this.$.eCanvas.getContext('2d');
        this.cvsOff = document.createElement('canvas');
        this.ctxOff = this.cvsOff.getContext('2d');

        // Sizing.
        this.$.eCanvas.width = this.cvsOff.width = this.width;
        this.$.eCanvas.height = this.cvsOff.height = this.height;

        // Registering mouse handler.
        this._registerMouseHandler();
      }

    });

  </script>
</polymer-element>