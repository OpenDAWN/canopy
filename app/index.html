<html>
<head>
  <title>Canopy &#9835;</title>
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  
  <script src="bower_components/webcomponentsjs/webcomponents.js"></script>
  <link rel="import" href="bower_components/core-toolbar/core-toolbar.html">
  <link rel="import" href="bower_components/core-menu/core-menu.html">
  <link rel="import" href="bower_components/core-item/core-item.html">
  <link rel="import" href="bower_components/core-header-panel/core-header-panel.html">
  <link rel="import" href="bower_components/core-drawer-panel/core-drawer-panel.html">
  <link rel="import" href="bower_components/core-scaffold/core-scaffold.html">

  <link href="bower_components/font-roboto/roboto.html" rel="import">
  <link href="bower_components/core-icon/core-icon.html" rel="import">
  <link href="bower_components/core-icons/core-icons.html" rel="import">
  <link href="bower_components/paper-button/paper-button.html" rel="import">

  <script src="codemirror/lib/codemirror.js"></script>
  <link rel="stylesheet" href="codemirror/lib/codemirror.css">
  <script src="codemirror/mode/javascript/javascript.js"></script>

  <script src="js/complex_array.js"></script>
  <script src="js/fft.js"></script>
  <script src="js/fft_image.js"></script>
  <script src="js/events.js"></script>

  <style>

    html, body {
      height: 100%;
      margin: 0;
    }
  
    body {
      font-family: RobotoDraft, 'Helvetica Neue', Helvetica, Arial;
      font-size: 14px;
      margin: 0;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -webkit-touch-callout: none;
    }
    
    .content {
      background-color: #fff;
      height: 5000px;
      padding: 20px;
    }

    paper-button.colored {
      color: #4285f4;
    }

    paper-button[raised].colored {
      background: #3e50b4;
      color: #fff;
    }

    paper-button.custom > core-icon {
      margin-right: 4px;
    }

    paper-button.hover:hover {
      background: #eee;
    }

    paper-button.blue-ripple::shadow #ripple {
      color: #4285f4;
    }
        
  </style>
  
</head>

<body fullbleed layout horizontal>

  <core-header-panel style="width: 500px;">
    <core-toolbar style="background-color: #607D8B; color: #ECEFF1;">
      <core-icon-button icon="menu"></core-icon-button>
      <span flex>Canopy &#9835;</span>
      <core-icon-button icon="send" onclick="executeCode();"></core-icon-button>
    </core-toolbar>
    <div vertical layout>
      <div id="i-editor" flex></div>
      <div id="i-editor-console" style="background-color:#fee; height:200px">2</div>
    </div>
  </core-header-panel>
    
  <core-header-panel flex>
    <core-toolbar style="background-color: #546E7A;">
      
    </core-toolbar>
    <div vertical layout flex>
      <div id="i-viewer" flex>
        <canvas id="i-waveform-a"></canvas>
        <canvas id="i-specgram-a"></canvas>
      </div>
      <div id="i-viewer-info" style="height:400px"></div>
    </div>
  </core-header-panel>

  <script>
    var editorDOM = document.querySelector('#i-editor');
    var consoleDOM = document.querySelector('#i-editor-console');
    var waveformDOM = document.querySelector('#i-waveform-a');
    var spectrogramDOM = document.querySelector('#i-specgram-a');

    var context2D = waveformDOM.getContext('2d');
    context2D.canvas.width = 1200;
    context2D.canvas.height = 300;

    var contextRT = new AudioContext();

    var lastRenderedChannelData = null;
    var spectrogramData = null;
    
    var zoomLevel = 0;
    var sampleHopSize = 1;
    var xInterval = 1;
    var sampleIndexOffset = 0;


    function createHanningWindow(length) {
      var phase = 0;
      var delta = 2 * Math.PI / length;
      var window_ = new Float32Array(length);
      for (var i = 0; i < length; i++) {
        window_[i] = 0.5 * (1.0 - Math.cos(phase));
        phase += delta;
      }
      return window_;
    }

    function createBlackmanWindow(length) {
      var alpha = 0.16;
      var a0 = 0.5 * (1 - alpha);
      var a1 = 0.5;
      var a2 = 0.5 * alpha;
      var window_ = new Float32Array(length);
      for (var i = 0; i < length; i++) {
        var x = i / length;
        var cos = Math.cos(Math.PI * 2 * x);
        window_[i] = a0 - a1 * cos + a2 * cos;
      }
      return window_;
    }


    /**
     * Render waveform view based on parameters.
     * @param  {Object} ctx 2D rendering context.
     * @param  {Float32Array} channelData AudioBuffer channel data.
     * @param  {Number} startPosition Start position in sample (integer).
     * @param  {Number} hopSize Sample hop size.
     * @param  {Number} interval Rendering interval on X-axis.
     * @param  {Number} viewWidth View width.
     * @param  {Number} viewHeight View Height.
     */
    function renderView(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight) {
      ctx.clearRect(0, 0, viewWidth, viewHeight);

      var index = startPosition;
      var length = channelData.length;
      var y_length, y_offset;
      
      ctx.strokeStyle = "#03A9F4";
      ctx.beginPath();

      // When the zoom level is above 'sample-level', use simple rendering 
      // for optimum performance.
      if (interval === 1) {
        for (var x = 0; x < viewWidth; x++) {
          if (index < length) {
            y_length = Math.abs(channelData[index]) * viewHeight;
          } else {
            y_length = 0.0;
          }
          y_offset = (viewHeight - y_length) * 0.5;
          ctx.moveTo(x, y_offset);
          ctx.lineTo(x, y_offset + y_length);
          index += hopSize;
        }

      } else {

        // If the zoom level is below sample-level, use linear-interpolation 
        // (line drawing) between samples.
        var numSamples = Math.min(viewWidth, (channelData.length - startPosition) / interval);
        var x_offset = 0;
        for (i = 0; i < numSamples; i++) {
          if (index < length) {
            y_offset = channelData[startPosition + i] * 0.5 + 0.5;
          } else {
            y_offset = 0.5;
          }
          y_offset *= viewHeight;
          ctx.lineTo(x_offset, y_offset);
          x_offset += interval;
        }
      }

      ctx.stroke();
    }

    function renderRuler(ctx, startPosition, hopSize, interval, viewWidth) {

      // ctx.fillStyle = '#CCC';
      // ctx.strokeStyle = '#666';
      // ctx.lineWidth = 0.5;
      // ctx.fillRect(0, 0, viewWidth, 20);

      // var index = startPosition;
      
      // ctx.beginPath();
      // for (var x = 0; x < viewWidth; x++) {
      //   var y_length = 0;
      //   if (index % 1000 === 0) {
      //     y_length = 20;
      //   } else if (index % 250 === 0) {
      //     y_length = 10;
      //   }
      //   if (y_length !== 0) {
      //     ctx.moveTo(x, 0);
      //     ctx.lineTo(x, y_length);  
      //   }
      //   index = Math.round(index + 1.0 / zoomFactor);
      // }
      // ctx.stroke();
      
    }

    var hanning = createHanningWindow(256);
    var blackman = createBlackmanWindow(256);

    function renderSpectrogram(canvasID, data) {
      var contextSpec = spectrogramDOM.getContext('2d');
      var width = 1200;
      var height = 300;
      spectrogramDOM.width = width;
      spectrogramDOM.height = height;
      contextSpec.strokeStyle = 'blue';
      contextSpec.clearRect(0, 0, width, height);
      
      spectrogramData = new complex_array.ComplexArray(256);

      var frame = 0;
      
      // for (var frame = 0; frame < ~~(44100 / 128); frame++) {

        spectrogramData.map(function (value, i, n) {
          // value.real = hanning[i] * lastRenderedChannelData[frame * 128 + i];
          // value.real = blackman[i] * lastRenderedChannelData[frame * 128 + i];
          value.real = lastRenderedChannelData[frame * 128 + i];
          // console.log(value.real);
        });
        
        spectrogramData.FFT();

        var nyquist = spectrogramData.real.length * 0.5;
        var real = spectrogramData.real;
        var imag = spectrogramData.imag;

        for (var i = 0; i < spectrogramData.imag.length; i++) {
          console.log(spectrogramData.imag[i]);
        }

        imag[0] = 0.0; // To blow above the nyquist.
        var magScale = 1.0 / 256;
        var minDecibel = -120;
        
        for (var i = 0; i < nyquist; i++) {
          var value = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]) * magScale;
          var db = Math.max(minDecibel, 20 * Math.log10(value));
          db = 1.0 + (db * 0.01);
          // console.log(db);
          contextSpec.fillStyle = 'rgba(0, 0, 0, ' + db + ')';
          contextSpec.fillRect(frame * 5, i * 5, 5, 5);
        }

      // }
    }

    function render(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight) {
      renderView(ctx, channelData, startPosition, hopSize, interval, viewWidth, viewHeight);
      renderRuler(ctx, startPosition, hopSize, interval, viewWidth);
    }

    function updateView() {
      render(context2D, 
        lastRenderedChannelData, 
        sampleIndexOffset, 
        Math.max(1, sampleHopSize), 
        Math.max(1, xInterval), 
        context2D.canvas.width, 
        context2D.canvas.height);
    }

    function zoom(delta) {
      // Scroll down, zoom in.
      if (delta < 0) {
        xInterval++;
        sampleHopSize--;
      } else if (delta > 0) {
        xInterval--;
        sampleHopSize++;
      }
      updateView();
    }

    function pan(deltaX) {
      sampleIndexOffset += (deltaX * Math.max(1, sampleHopSize));
      sampleIndexOffset = Math.max(0, sampleIndexOffset);
      updateView();
    }

    var prevX = 0, dX = 0;

    var mouseHandler = new MouseResponder('waveform', waveformDOM, 
      function (sender, action, data) {
        // console.log(action, data);
        switch (action) {
          case 'clicked':
            prevX = data.x;
            deltaX = 0;
            break;
          case 'dragged':
            dX = prevX - data.x;
            pan(dX);
            prevX = data.x;
            break;
          case 'wheelmoved':
            // console.log(data.wheelDelta);
            zoom(data.wheelDelta);
            break;
        }
      }
    );


    function sampleCode() {
// Edit the code below and 'Run' it.
// var osc1 = context.createOscillator();
// var modGain = context.createGain();
// var osc2 = context.createOscillator();
// osc1.connect(modGain);
// modGain.connect(osc2.frequency);
// osc2.connect(context.destination);
// osc1.frequency.value = 33;
// modGain.gain.value = 3735;
// osc2.frequency.value = 77;
// osc1.start();
// osc2.start();
var osc1 = context.createOscillator();
osc1.frequency.value = 1000;
osc1.connect(context.destination);
osc1.start();
}

    var myCodeMirror = CodeMirror(editorDOM, {
      value: sampleCode.toString().slice(24, -1),
      mode: 'javascript'
    });

    // Spawns a task with the code from CodeMirror editor.
    var spawnTask = (function () {

      function Task(str) {
        this.injectTaskFromString(str);
      }

      Task.prototype.injectTaskFromString = function (str) {
        var header = 'var context = new OfflineAudioContext(2, 44100, 44100);';
        var footer = 'context.oncomplete = this.onRenderComplete; context.startRendering();';
        
        // WARNING: be careful with Function. It is same with 'eval()'.
        this.task = new Function('', header + str + footer);
      };

      Task.prototype.run = function () {
        try {
          this.task();  
        } catch (e) {
          var message = '[' + e.name + '] ' + e.message;
          consoleDOM.textContent = message;
          console.log(e.stack);
        }
      };

      Task.prototype.onRenderComplete = function (event) {
        var source = contextRT.createBufferSource();
        source.buffer = event.renderedBuffer;
        source.connect(contextRT.destination);
        source.start();
        lastRenderedChannelData = event.renderedBuffer.getChannelData(0);
        updateView();
        renderSpectrogram('i-spectragram-a', spectrogramData);
      };

      return function (str) {
        new Task(str).run();  
      };

    })();

    function executeCode() {
      spawnTask(myCodeMirror.getValue());
    }
  </script>

</body>
</html>